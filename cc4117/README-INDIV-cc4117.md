# Individual Statement - cc4117


# Order of Module compilation: 
1. `SimulationTypes` - Contains Block type which is used in `Simulator` for simulation
2. `Helper` - Contains functions that handle boilerplate and conversions between the `GeneralNet` type and `Map<NetIdentifier,Net>` type which is used in evaluation
3. `SynchronousBlocks` - Contains synchronous blocks defined in F# (currently only DFF is implemented). The top level function is `evaluateSyncBlock` which takes in a MegaBlock and returns the correct function to evaluate the synchronous logic
4. `CombEval` - Module written by anv17, top level function is `evaluateModuleWithInputs` which evaluates asynchronous logic defined by the `tLogic` type.
5. `Simulator` - Contains top level functions `advanceState` which advances the current state of the circuit and `simulate` which repeatedly advances the state as long as there are inputs 

# Top Level Functions
The top level function 'simulate' contains 3 parameters:
* `lstOfInputs: GeneralNet list list` - List of list of inputs which is defined by the user 
* `cLst: Connection list` - Defines how wires are connected to MegaBlocks (taken from Connectioniser module - written by mq3617)
* `tLst: TLogic list` - List of TLogic that is present in the circuit generated by tkh2017 (used for evaluation) 

The function 'advanceState' makes use of the `Block` type which is a connection whose inputs and outputs are defined by the `Map<NetIdentifier,Net` type instead of the `GeneralNet list` type. This is crucial as all evaluation is done using maps.
The parameters required are: 
* `initMap: Map<NetIdentifier,Net>` - Initial map which consists of the overall inputs of the circuit as well as the states of all synchronous nets in the circuit (initialized to Low by default)
* `asyncBLst: Block list` - List of asynchronous megablocks with map inputs and outputs
* `syncBLst: Block list` List of synchronous megablocks with map inputs and outputs
* `tLst: TLogic list` - List of TLogic that is present in the circuit (used for evaluation). </br>
The output of `advanceState` is the next state of all synchronous states which is used in the next clock cycle. There are also print statements which can be uncommented to give the state of all values in the circuit after asynchronous and synchronous evaluation. 

The top level function `evaluateSyncBlock` has only 1 parameter:
* `mBlock: MegaBlock` - Used to identify which synchronous evaluation function should be called. </br>
The function returns another function with the signature `Map<NetIdentifier,Net> -> Map<NetIdentifier,Net> -> Map<NetIdentifier,Net>`.

# How will my code be used in the group?
My code takes in various parameters from other group members as mentioned above, and uses it to simulate the circuit defined by the user over multiple clock cycles and I have written it in a way that makes it easy for a GUI to be built on top of it.

*None of my code is written for/by others.*

My part depended heavily on the types defined by the other group members, especially those involved in evaluation (e.g. `GeneralNet`, `NetIdentifier`). To make the individual coding go as smoothly as possible, we all notified each other when shared types were being changed and gave the signatures of our top level functions. Also I made sure to take time to review/understand the workflow of anv17 and mq3617 to avoid misunderstandings and correctly interface their code with mine.   

The code that I have delivered meets the requirements outlined in the teamwork plan. As the simulation is the end of the workflow, my code will potentially be used to create a GUI to provide the user with an easy way to view the state of the circuit during simulation.




